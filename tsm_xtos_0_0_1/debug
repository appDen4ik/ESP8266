

http://habrahabr.ru/post/188712/



/тест findLine
тест 1. Находит ли функция записи 
меняя длину строки 100..103
..................................................................................................................................
		uint8_t *data0 = "1TESTqwertyuiopQWERTYUIOPasdfghjkl;ASDFGHJKL;zxcvbnm,./ZXCVBNM,./1234567890!@#$%^&*()testlines TEST122";
        static uint8_t nul[100];

		uint16_t c, currentSector;
		uint32_t a, i;

		clearSectorsDB();

		os_printf( " \n %s \n String Size %d", data0, (strlen(data0) + 1) );

		ets_uart_printf(" Тест 1 запись строки и дальнейший поиск ее же, и так по всей памяти: ");

		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR;  currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			for ( i = 0; i + ALIGN_STRING_SIZE < SPI_FLASH_SEC_SIZE; i += ALIGN_STRING_SIZE ) {

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)data0, ALIGN_STRING_SIZE );

				switch ( a = findLine( data0 ) ){

						case WRONG_LENGHT:
							ets_uart_printf("WRONG_LENGHT");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						case NOTHING_FOUND:
							ets_uart_printf("NOTHING_FOUND");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							     uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						case OPERATION_FAIL:
							ets_uart_printf("OPERATION_FAIL");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
									uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						default:
							ets_uart_printf("OPERATION_OK");
							break;

				}

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)nul, ALIGN_STRING_SIZE );

			}			

			os_printf( " Проверка %d сектора закончена", currentSector );
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
				for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
					uart_tx_one_char(tmpTest[c]);
			}
		}

m:
................................................................................................................................
тест 2. Проверка находит ли запись, а также не находит ли записи которых реально нет в куче. Сначала куча наполняется значениями 
        1... до конца кучи выровняные по длине в 50 байт. Далее эти же значение запрашиваются. Далее запрашивается рад разных 
        значаний и проверяется факт не нахождения строк. 
	{	//тест findLine
	//

		uint32_t data0 = 0;
		uint16_t data3 = 0;
		uint8_t ascii[10];
		static uint8_t string[STRING_SIZE];
		uint8_t alignString[ALIGN_STRING_SIZE];
		uint8_t *p;

		uint16_t c, currentSector;
		uint32_t a, i;


		alignString[ STRING_SIZE - 1 ] = '\0';

		for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
			alignString[i] = 0xff;
		}

		string[STRING_SIZE - 1] = '\0';
		clearSectorsDB();

	//	os_printf( " \n %s \n String Size %d", data0, (strlen(data0) + 1) );

		os_delay_us(500000);

		ets_uart_printf(" Проверка findLine Тест 2 ");

		os_delay_us(500000);

		ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравнеными по 50 символов  ");

		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR;  currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);

			for ( i = 0; i + ALIGN_STRING_SIZE < SPI_FLASH_SEC_SIZE; i += ALIGN_STRING_SIZE ) {

				for ( a = 0; a < STRING_SIZE - 1; a++ ) {
							alignString[a] = '0';
				}

				data0++;
				p = ShortIntToString(data0, ascii);

				memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)alignString, ALIGN_STRING_SIZE );

			}


/*			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
				for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
					uart_tx_one_char(tmpTest[c]);
			}
*/
		}

		data3 = data0 + 1;
		ets_uart_printf(" П.2 Поиск всех значений в обратном порядке ");

		for ( ; data0 > 0; data0-- ) {
			os_printf( " data %d", data0);
			p = ShortIntToString(data0, ascii);
			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
						string[a] = '0';
			}
			memcpy( &string[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			os_printf( " data %s", string);
		switch ( a = findLine( string ) ){

					case WRONG_LENGHT:
						ets_uart_printf("WRONG_LENGHT");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case NOTHING_FOUND:
						ets_uart_printf("NOTHING_FOUND");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
						     uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case OPERATION_FAIL:
						ets_uart_printf("OPERATION_FAIL");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					default:
						ets_uart_printf("OPERATION_OK");
						break;

			}
		system_soft_wdt_stop();

		}

		ets_uart_printf(" П.3 Поиск всех несуществующих значений uint16_t ");

		for ( ; data3 != 0; data3++ ) {
			os_printf( " data %d", data3);
			p = ShortIntToString(data3, ascii);
			memcpy( &string[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		switch ( a = findLine( string ) ){

					case WRONG_LENGHT:
						ets_uart_printf("WRONG_LENGHT");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case NOTHING_FOUND:
						ets_uart_printf("NOTHING_FOUND");
						break;

					case OPERATION_FAIL:
						ets_uart_printf("OPERATION_FAIL");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					default:
						ets_uart_printf("OPERATION_OK");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
						     uart_tx_one_char(tmpTest[c]);
						}
						goto m;


			}
		system_soft_wdt_stop();

		}

		ets_uart_printf(" Тест успешно окончен ");




	}
m:
................................................................................................................................
................................................................................................................................
................................................................................................................................




Проверка функции insert( uint8_t *line )
Тест 1. Полное заполнение db, последовальностью значений от 0..., выровняных по ширине в 100 байт.

	uint32_t data0 = 0;
	uint16_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];
	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка insertLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравняными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

		os_delay_us(500000);
		ets_uart_printf(" Запрос db ");
		os_delay_us(500000);


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
		}
................................................................................................................................
Тест 2.	Проверка LINE_ALREADY_EXIST. Заполненние db как в тесте 1, далее в обратном порядке поиск строк, при 
        совпадении строка затирается.
        
	uint32_t data0 = 0;
	uint16_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];
	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравнеными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}


	os_delay_us(500000);
	ets_uart_printf(" Запрос db ");
	os_delay_us(500000);


	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
	}


	os_delay_us(500000);
	ets_uart_printf(" Пункт 2 ");
	os_delay_us(500000);


	for  (data0--; data0 > 0; data0-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				system_soft_wdt_stop();
				break;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;
		}

	}



		os_delay_us(500000);
		ets_uart_printf(" Запрос db ");
		os_delay_us(500000);


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}

		os_delay_us(500000);
		ets_uart_printf(" Тестирование успешно завершено ");
		os_delay_us(5000000);


m:
       
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------

Проверка функции update( uint8_t *line ). Заполнения бд с помощью функции insert, далее увеличение каждого значения на вели -
чину количества записей.
	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка updateLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выровняными по 101 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

//		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				//ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

	os_delay_us(500000);
	ets_uart_printf(" Запрос db ");
	os_delay_us(500000);


	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
		system_soft_wdt_stop();
	}
	
		os_delay_us(500000);
		ets_uart_printf(" Проверка updateLine Тест 1 . Увеличения значения в каждой записи");
		os_delay_us(500000);

		data0--;

		for ( data3 = 1; data3 <= data0; data3++ ) {


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignStr[a] = '0';
			}

			p = ShortIntToString(data3, ascii);
			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignString[STRING_SIZE - 1] = '\0';

			a = data0 + data3;

			p = ShortIntToString(a, ascii);
			memcpy( &alignStr[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignStr[STRING_SIZE - 1] = '\0';

			os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );
			os_printf( " \n %s \n String 2 lenght %d", alignStr, (strlen(alignStr) + 1) );

			switch ( res = update( alignString, alignStr ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					system_soft_wdt_stop();
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		}


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}

--------------Проверка что при обновлении несуществующей записи функция корректно отработает---------------------

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка updateLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выровняными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

//		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				//ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

		os_delay_us(500000);
		ets_uart_printf(" Проверка updateLine Тест 1 . Проверка что при обновлении несуществующей записи функция корректно отработает");
		os_delay_us(500000);


		data0 = data3;

		for ( i = 0; i < 2; i++, data0++, data3++ ) {


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignStr[a] = '0';
			}

			p = ShortIntToString(data3, ascii);
			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignString[STRING_SIZE - 1] = '\0';



			p = ShortIntToString(data0, ascii);
			memcpy( &alignStr[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignStr[STRING_SIZE - 1] = '\0';

			os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );
			os_printf( " \n %s \n String 2 lenght %d", alignStr, (strlen(alignStr) + 1) );

			switch ( res = update( alignString, alignStr ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					break;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					break;
			}

		}


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}



		ets_uart_printf(" Тестирование успешно завершено ");
		
m:
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
        
Проверка функции delete. Тест 1. Заполняю первый сектор записями длинной кратной 4 которые не полностью забивают сектор.
Потом удаляю всегда последнюю запись по сектор не очиститься.

	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление последненй записи " );
	os_delay_us(500000);


	for ( i = SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i > 0; i-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

Проверка функции delete. Тест 2. Заполняю первый сектор записями длинной кратной 4 которые полностью забивают сектор.
Потом удаляю всегда последнюю запись по сектор не очиститься.

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление последненй записи " );
	os_delay_us(500000);


	for ( i = SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i > 0; i-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

Проверка функции delete. Тест 3. Заполняю первый сектор записями длинной не кратной 4.
Потом удаляю всегда последнюю запись по сектор не очиститься, как и тест 1.

Проверка функции delete. Тест 4. Заполняю первый сектор записями длинной  кратной 4 которые не полностью забивают сектор,
длинной кратной 4, которые полностью забивают сектор, а также записями не кратными 4
Потом удаляю всегда запись которая всегда идет первоей в секторе пока не сектор полностью не очиститься.

	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление первой записи " );
	os_delay_us(500000);


	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 256 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление первой записи " );
	os_delay_us(500000);


	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}
======================================================================================================================================
======================================================================================================================================
======================================================================================================================================





  Проверка requestString( ). Тест 1.  Заполняем первый сектор, записями с одним полем выровняным по правому краю. Поле начинается 
  START_OF_FIELD и заканчивается END_OF_FIELD. И проверка что все записи будут найдены. Длинна записей кратные 4, не кратные 4, и 
  кратные 4 которые заполняют полностью сектор.
  
  uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];


	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 101 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

			spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			system_soft_wdt_stop();
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}


	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

  Проверка requestString( ). Тест 2.  Заполняем первый сектор, записями с несколькими полями ( с тремя, одно поле
  справа одно слева. Поле начинается START_OF_FIELD и заканчивается END_OF_FIELD. И проверка что все записи
  будут найдены. Длинна записей кратные 4, не кратные 4, и кратные 4 которые заполняют полностью сектор. Далее 
  проверка что поля которых не будут найдены.

static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";


	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 101 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

		alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

			spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			system_soft_wdt_stop();
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

/*		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;
*/

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}
	
	
os_delay_us(500000);
		ets_uart_printf( " П. 3 - Проверка что функция не находит записи когда поля такого рельно нету " );
		os_delay_us(500000);



		for ( ; i <= 2500; i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			if ( i == 2500 ) {
				p = ShortIntToString( 0, ascii );
			} else {
				p = ShortIntToString( i, ascii );
			}

			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

			alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = requestString( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					system_soft_wdt_stop();
					break;

			}
		}
	


	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	os_delay_us(500000);
	system_soft_wdt_stop();
}
  
  Проверка requestString( ). Тест 3.  Заполняем первый сектор, записями с несколькими полями ( с тремя, одно поле
  справа одно слева. Поле начинается START_OF_FIELD и заканчивается END_OF_FIELD. Далее передача функции записи
  с тремя полями записей в куче которые совпадали бы с двумя первыми полями нет. Проверка что будут найдены 
  все записи которые реально есть, а также проверка что не будут найдены поля которых в куче нет.  

	static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";

	uint8_t string2[] = "HELLO1";
	uint8_t string3[] = "Тестирование1";

	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем значениями (ASCII) выровняными по 100 символов  ");

	for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ) ; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 95 ], string, strlen(string) );
		alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );
		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

//	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
/*		os_delay_us(1000000);
		system_soft_wdt_stop();
	}
*/


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ) ; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );


		memcpy( &alignString[ STRING_SIZE - 95 ], string, strlen(string) );
		alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );
		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}



	os_delay_us(500000);
		ets_uart_printf( " П. 3 - Проверка что функция не находит записи когда поля такого рельно нету " );
		os_delay_us(500000);



		for ( ; i <= 2500; i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			if ( i == 2500 ) {
				p = ShortIntToString( 0, ascii );
			} else {
				p = ShortIntToString( i, ascii );
			}


			memcpy( &alignString[ STRING_SIZE - 95 ], string2, strlen(string2) );
			alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
			alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


			memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string3, strlen( string3 ) );
			alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = requestString( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					system_soft_wdt_stop();
					break;

			}
		}

	ets_uart_printf(" Тестирование успешно завершено ");




m:

while ( 1 ) {
	os_delay_us(500000);
	system_soft_wdt_stop();
}













http://habrahabr.ru/post/188712/



/тест findLine
тест 1. Находит ли функция записи 
меняя длину строки 100..103
..................................................................................................................................
		uint8_t *data0 = "1TESTqwertyuiopQWERTYUIOPasdfghjkl;ASDFGHJKL;zxcvbnm,./ZXCVBNM,./1234567890!@#$%^&*()testlines TEST122";
        static uint8_t nul[100];

		uint16_t c, currentSector;
		uint32_t a, i;

		clearSectorsDB();

		os_printf( " \n %s \n String Size %d", data0, (strlen(data0) + 1) );

		ets_uart_printf(" Тест 1 запись строки и дальнейший поиск ее же, и так по всей памяти: ");

		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR;  currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			for ( i = 0; i + ALIGN_STRING_SIZE < SPI_FLASH_SEC_SIZE; i += ALIGN_STRING_SIZE ) {

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)data0, ALIGN_STRING_SIZE );

				switch ( a = findLine( data0 ) ){

						case WRONG_LENGHT:
							ets_uart_printf("WRONG_LENGHT");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						case NOTHING_FOUND:
							ets_uart_printf("NOTHING_FOUND");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							     uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						case OPERATION_FAIL:
							ets_uart_printf("OPERATION_FAIL");
							spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
							for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
									uart_tx_one_char(tmpTest[c]);
							}
							goto m;

						default:
							ets_uart_printf("OPERATION_OK");
							break;

				}

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)nul, ALIGN_STRING_SIZE );

			}			

			os_printf( " Проверка %d сектора закончена", currentSector );
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
				for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
					uart_tx_one_char(tmpTest[c]);
			}
		}

m:
................................................................................................................................
тест 2. Проверка находит ли запись, а также не находит ли записи которых реально нет в куче. Сначала куча наполняется значениями 
        1... до конца кучи выровняные по длине в 50 байт. Далее эти же значение запрашиваются. Далее запрашивается рад разных 
        значаний и проверяется факт не нахождения строк. 
	{	//тест findLine
	//

		uint32_t data0 = 0;
		uint16_t data3 = 0;
		uint8_t ascii[10];
		static uint8_t string[STRING_SIZE];
		uint8_t alignString[ALIGN_STRING_SIZE];
		uint8_t *p;

		uint16_t c, currentSector;
		uint32_t a, i;


		alignString[ STRING_SIZE - 1 ] = '\0';

		for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
			alignString[i] = 0xff;
		}

		string[STRING_SIZE - 1] = '\0';
		clearSectorsDB();

	//	os_printf( " \n %s \n String Size %d", data0, (strlen(data0) + 1) );

		os_delay_us(500000);

		ets_uart_printf(" Проверка findLine Тест 2 ");

		os_delay_us(500000);

		ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравнеными по 50 символов  ");

		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR;  currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);

			for ( i = 0; i + ALIGN_STRING_SIZE < SPI_FLASH_SEC_SIZE; i += ALIGN_STRING_SIZE ) {

				for ( a = 0; a < STRING_SIZE - 1; a++ ) {
							alignString[a] = '0';
				}

				data0++;
				p = ShortIntToString(data0, ascii);

				memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );

				spi_flash_write( SPI_FLASH_SEC_SIZE * currentSector + i, (uint32 *)alignString, ALIGN_STRING_SIZE );

			}


/*			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
				for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
					uart_tx_one_char(tmpTest[c]);
			}
*/
		}

		data3 = data0 + 1;
		ets_uart_printf(" П.2 Поиск всех значений в обратном порядке ");

		for ( ; data0 > 0; data0-- ) {
			os_printf( " data %d", data0);
			p = ShortIntToString(data0, ascii);
			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
						string[a] = '0';
			}
			memcpy( &string[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			os_printf( " data %s", string);
		switch ( a = findLine( string ) ){

					case WRONG_LENGHT:
						ets_uart_printf("WRONG_LENGHT");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case NOTHING_FOUND:
						ets_uart_printf("NOTHING_FOUND");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
						     uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case OPERATION_FAIL:
						ets_uart_printf("OPERATION_FAIL");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					default:
						ets_uart_printf("OPERATION_OK");
						break;

			}
		system_soft_wdt_stop();

		}

		ets_uart_printf(" П.3 Поиск всех несуществующих значений uint16_t ");

		for ( ; data3 != 0; data3++ ) {
			os_printf( " data %d", data3);
			p = ShortIntToString(data3, ascii);
			memcpy( &string[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		switch ( a = findLine( string ) ){

					case WRONG_LENGHT:
						ets_uart_printf("WRONG_LENGHT");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
							uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					case NOTHING_FOUND:
						ets_uart_printf("NOTHING_FOUND");
						break;

					case OPERATION_FAIL:
						ets_uart_printf("OPERATION_FAIL");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
								uart_tx_one_char(tmpTest[c]);
						}
						goto m;

					default:
						ets_uart_printf("OPERATION_OK");
						spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
						for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
						     uart_tx_one_char(tmpTest[c]);
						}
						goto m;


			}
		system_soft_wdt_stop();

		}

		ets_uart_printf(" Тест успешно окончен ");




	}
m:
................................................................................................................................
................................................................................................................................
................................................................................................................................




Проверка функции insert( uint8_t *line )
Тест 1. Полное заполнение db, последовальностью значений от 0..., выровняных по ширине в 100 байт.

	uint32_t data0 = 0;
	uint16_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];
	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка insertLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравняными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

		os_delay_us(500000);
		ets_uart_printf(" Запрос db ");
		os_delay_us(500000);


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
		}
................................................................................................................................
Тест 2.	Проверка LINE_ALREADY_EXIST. Заполненние db как в тесте 1, далее в обратном порядке поиск строк, при 
        совпадении строка затирается.
        
	uint32_t data0 = 0;
	uint16_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];
	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выравнеными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}


	os_delay_us(500000);
	ets_uart_printf(" Запрос db ");
	os_delay_us(500000);


	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
	}


	os_delay_us(500000);
	ets_uart_printf(" Пункт 2 ");
	os_delay_us(500000);


	for  (data0--; data0 > 0; data0-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				system_soft_wdt_stop();
				break;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;
		}

	}



		os_delay_us(500000);
		ets_uart_printf(" Запрос db ");
		os_delay_us(500000);


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}

		os_delay_us(500000);
		ets_uart_printf(" Тестирование успешно завершено ");
		os_delay_us(5000000);


m:
       
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------

Проверка функции update( uint8_t *line ). Заполнения бд с помощью функции insert, далее увеличение каждого значения на вели -
чину количества записей.
	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка updateLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выровняными по 101 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

//		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				//ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

	os_delay_us(500000);
	ets_uart_printf(" Запрос db ");
	os_delay_us(500000);


	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
		system_soft_wdt_stop();
	}
	
		os_delay_us(500000);
		ets_uart_printf(" Проверка updateLine Тест 1 . Увеличения значения в каждой записи");
		os_delay_us(500000);

		data0--;

		for ( data3 = 1; data3 <= data0; data3++ ) {


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignStr[a] = '0';
			}

			p = ShortIntToString(data3, ascii);
			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignString[STRING_SIZE - 1] = '\0';

			a = data0 + data3;

			p = ShortIntToString(a, ascii);
			memcpy( &alignStr[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignStr[STRING_SIZE - 1] = '\0';

			os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );
			os_printf( " \n %s \n String 2 lenght %d", alignStr, (strlen(alignStr) + 1) );

			switch ( res = update( alignString, alignStr ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					system_soft_wdt_stop();
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		}


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}

--------------Проверка что при обновлении несуществующей записи функция корректно отработает---------------------

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка updateLine Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем память значениями (ASCII) выровняными по 100 символов  ");

	for ( ; res != NOT_ENOUGH_MEMORY; ) {


		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}
		data0++;
		p = ShortIntToString(data0, ascii);
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

//		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				//ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				system_soft_wdt_stop();
				break;

		}

	}

		os_delay_us(500000);
		ets_uart_printf(" Проверка updateLine Тест 1 . Проверка что при обновлении несуществующей записи функция корректно отработает");
		os_delay_us(500000);


		data0 = data3;

		for ( i = 0; i < 2; i++, data0++, data3++ ) {


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}


			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignStr[a] = '0';
			}

			p = ShortIntToString(data3, ascii);
			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignString[STRING_SIZE - 1] = '\0';



			p = ShortIntToString(data0, ascii);
			memcpy( &alignStr[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
			alignStr[STRING_SIZE - 1] = '\0';

			os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );
			os_printf( " \n %s \n String 2 lenght %d", alignStr, (strlen(alignStr) + 1) );

			switch ( res = update( alignString, alignStr ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					break;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					break;
			}

		}


		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}



		ets_uart_printf(" Тестирование успешно завершено ");
		
m:
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
        
Проверка функции delete. Тест 1. Заполняю первый сектор записями длинной кратной 4 которые не полностью забивают сектор.
Потом удаляю всегда последнюю запись по сектор не очиститься.

	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление последненй записи " );
	os_delay_us(500000);


	for ( i = SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i > 0; i-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

Проверка функции delete. Тест 2. Заполняю первый сектор записями длинной кратной 4 которые полностью забивают сектор.
Потом удаляю всегда последнюю запись по сектор не очиститься.

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление последненй записи " );
	os_delay_us(500000);


	for ( i = SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i > 0; i-- ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

Проверка функции delete. Тест 3. Заполняю первый сектор записями длинной не кратной 4.
Потом удаляю всегда последнюю запись по сектор не очиститься, как и тест 1.

Проверка функции delete. Тест 4. Заполняю первый сектор записями длинной  кратной 4 которые не полностью забивают сектор,
длинной кратной 4, которые полностью забивают сектор, а также записями не кратными 4
Потом удаляю всегда запись которая всегда идет первоей в секторе пока не сектор полностью не очиститься.

	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 200 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление первой записи " );
	os_delay_us(500000);


	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

	uint32_t data0 = 0;
	uint32_t data3 = 0;
	uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];

	uint8_t alignString[ALIGN_STRING_SIZE];
	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка delete Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 256 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) ], ascii, (p - ascii) );
		alignString[STRING_SIZE - 1] = '\0';

		os_printf( " \n %s \n String lenght %d", alignString, (strlen(alignString) + 1) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto m;

		}

	}

	spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
	for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
		uart_tx_one_char(tmpTest[c]);
	}

	os_delay_us(500000);
	ets_uart_printf( " Проверка delete. Удаление первой записи " );
	os_delay_us(500000);


	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );
		memcpy( &alignString[ STRING_SIZE - 1 - ( p - ascii ) ], ascii, ( p - ascii ) );
		alignString[ STRING_SIZE - 1 ] = '\0';

		os_printf( " \n %s \n String 1 lenght %d", alignString, (strlen(alignString) + 1) );

			switch ( delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					goto m;
			}

		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}

	}

	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}
======================================================================================================================================
======================================================================================================================================
======================================================================================================================================





  Проверка requestString( ). Тест 1.  Заполняем первый сектор, записями с одним полем выровняным по правому краю. Поле начинается 
  START_OF_FIELD и заканчивается END_OF_FIELD. И проверка что все записи будут найдены. Длинна записей кратные 4, не кратные 4, и 
  кратные 4 которые заполняют полностью сектор.
  
  uint8_t ascii[10];
	static uint8_t string[STRING_SIZE];


	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 1 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 101 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

			spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			system_soft_wdt_stop();
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}


	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	system_soft_wdt_stop();
}

  Проверка requestString( ). Тест 2.  Заполняем первый сектор, записями с несколькими полями ( с тремя, одно поле
  справа одно слева. Поле начинается START_OF_FIELD и заканчивается END_OF_FIELD. И проверка что все записи
  будут найдены. Длинна записей кратные 4, не кратные 4, и кратные 4 которые заполняют полностью сектор. Далее 
  проверка что поля которых не будут найдены.

static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";


	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем начальный сектор значениями (ASCII) выровняными по 101 символов  ");

	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

		alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

			spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			system_soft_wdt_stop();
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

/*		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;
*/

		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

		alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}
	
	
os_delay_us(500000);
		ets_uart_printf( " П. 3 - Проверка что функция не находит записи когда поля такого рельно нету " );
		os_delay_us(500000);



		for ( ; i <= 2500; i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			if ( i == 2500 ) {
				p = ShortIntToString( 0, ascii );
			} else {
				p = ShortIntToString( i, ascii );
			}

			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

			alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = requestString( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					system_soft_wdt_stop();
					break;

			}
		}
	


	ets_uart_printf(" Тестирование успешно завершено ");

m:

while ( 1 ) {
	os_delay_us(500000);
	system_soft_wdt_stop();
}
  
  Проверка requestString( ). Тест 3.  Заполняем первый сектор, записями с несколькими полями ( с тремя, одно поле
  справа одно слева. Поле начинается START_OF_FIELD и заканчивается END_OF_FIELD. Далее передача функции записи
  с тремя полями записей в куче которые совпадали бы с двумя первыми полями нет. Проверка что будут найдены 
  все записи которые реально есть, а также проверка что не будут найдены поля которых в куче нет.  

	static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";

	uint8_t string2[] = "HELLO1";
	uint8_t string3[] = "Тестирование1";

	uint8_t alignStr[ALIGN_STRING_SIZE];

	uint8_t *p;

	uint16_t c, currentSector;
	uint32_t a, i;

	result res;


	for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
		alignString[i] = 0xff;
	}

	clearSectorsDB();

	os_delay_us(500000);

	ets_uart_printf(" Проверка requestString. Тест 2 ");

	os_delay_us(500000);

	ets_uart_printf(" П.1 Заполняем значениями (ASCII) выровняными по 100 символов  ");

	for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ) ; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );

		memcpy( &alignString[ STRING_SIZE - 95 ], string, strlen(string) );
		alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );
		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = insert( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case LINE_ALREADY_EXIST:
				ets_uart_printf("LINE_ALREADY_EXIST");
				goto m;
			case NOT_ENOUGH_MEMORY:
			ets_uart_printf("NOT_ENOUGH_MEMORY");
			goto c;

		}

	}

c:
	os_delay_us(1000000);

//	for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
		os_printf( " currentSector   %d", currentSector);
		spi_flash_read( SPI_FLASH_SEC_SIZE * START_SECTOR, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
		for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
			uart_tx_one_char(tmpTest[c]);
		}
/*		os_delay_us(1000000);
		system_soft_wdt_stop();
	}
*/


	os_delay_us(500000);
	ets_uart_printf( " П. 2 - Поиск всех записей переданых в прошлом пункте" );
	os_delay_us(500000);



	for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ) ; i++ ) {

		for ( a = 0; a < STRING_SIZE - 1; a++ ) {
				alignString[a] = '0';
		}

		p = ShortIntToString( i, ascii );


		memcpy( &alignString[ STRING_SIZE - 95 ], string, strlen(string) );
		alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


		memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
		alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
		alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


		memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );
		alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
		alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

		os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

		switch ( res = requestString( alignString ) ) {
			case OPERATION_OK:
				ets_uart_printf("OPERATION_OK");
				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case WRONG_LENGHT:
				ets_uart_printf("WRONG_LENGHT");
				goto m;
			case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
				goto m;

		}
	}



	os_delay_us(500000);
		ets_uart_printf( " П. 3 - Проверка что функция не находит записи когда поля такого рельно нету " );
		os_delay_us(500000);



		for ( ; i <= 2500; i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			if ( i == 2500 ) {
				p = ShortIntToString( 0, ascii );
			} else {
				p = ShortIntToString( i, ascii );
			}


			memcpy( &alignString[ STRING_SIZE - 95 ], string2, strlen(string2) );
			alignString[ STRING_SIZE - 96 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 80 ]  = END_OF_FIELD;


			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 ], ascii, (p - ascii) );
			alignString[ STRING_SIZE - 15 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2  ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


			memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string3, strlen( string3 ) );
			alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = requestString( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case NOTHING_FOUND:
					ets_uart_printf("NOTHING_FOUND");
					system_soft_wdt_stop();
					break;

			}
		}

	ets_uart_printf(" Тестирование успешно завершено ");




m:

while ( 1 ) {
	os_delay_us(500000);
	system_soft_wdt_stop();
}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Проверка функции query. Тест 1. Полное заполнение выделенной памяти 3 - мя видами записей с дальнейшим их запросом.
	uint8_t ascii[10];
	static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";


	uint16_t lenght;
	uint32_t adress;


		uint8_t alignStr[ALIGN_STRING_SIZE];

		uint8_t *p;

		uint16_t c, currentSector;
		uint32_t a, i;

		result res;


		for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
			alignString[i] = 0xff;
		}

		clearSectorsDB();

		os_delay_us(500000);
		ets_uart_printf(" Проверка query. Тест 1 ");
		os_delay_us(500000);


		ets_uart_printf(" П.1 Заполняем базу значениями (ASCII) выровняными по ALIGN_STRING_SIZE символов  ");

		for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ); i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			p = ShortIntToString( i, ascii );

			memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

			alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

			alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


			memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

			alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = insert( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					system_soft_wdt_stop();
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					goto m;
				case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto c;

			}

		}

	c:

/*		for ( currentSector = START_SECTOR; currentSector <= START_SECTOR + 3; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}
*/
		os_delay_us(500000);
		ets_uart_printf(" Проверка query. Тест 2.  ");
		os_delay_us(500000);

		lenght = 0;
		adress = 0;
		a = 0;

		for ( ; ; ) {

			switch (  query( storage, &lenght, &adress ) ) {
				case OPERATION_OK:
				a++;
				ets_uart_printf("OPERATION_OK");
				os_printf( " Lenght  %d  adress  %d ", lenght, adress );
				os_delay_us(500000);
				os_printf( " Counter  %d ", a );
				os_delay_us(500000);
				uart0_tx_buffer( storage, lenght );

				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case READ_DONE:
				ets_uart_printf("READ_DONE");
				os_printf( " Lenght  %d  adress  %d ", lenght, adress );
				uart0_tx_buffer( storage, lenght );

				goto q;

		}
}


q:

	ets_uart_printf(" Тестирование успешно завершено ");

m:

	while ( 1 ) {
		os_delay_us(500000);
		system_soft_wdt_stop();
	}

Тест 2. Частичное заполнение секторов.

	uint8_t ascii[10];
	static uint8_t string[] = "HELLO";
	static uint8_t string1[] = "Тестирование";


	uint16_t lenght;
	uint32_t adress;


		uint8_t alignStr[ALIGN_STRING_SIZE];

		uint8_t *p;

		uint16_t c, currentSector;
		uint32_t a, i;

		result res;


		for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
			alignString[i] = 0xff;
		}

		clearSectorsDB();

		os_delay_us(500000);
		ets_uart_printf(" Проверка query. Тест 2 ");
		os_delay_us(500000);


		ets_uart_printf(" П.1 Заполняем базу значениями (ASCII) выровняными по ALIGN_STRING_SIZE символов  ");

		for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ); i++ ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			p = ShortIntToString( i, ascii );

			memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

			alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

			alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


			memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

			alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = insert( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					system_soft_wdt_stop();
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case LINE_ALREADY_EXIST:
					ets_uart_printf("LINE_ALREADY_EXIST");
					goto m;
				case NOT_ENOUGH_MEMORY:
				ets_uart_printf("NOT_ENOUGH_MEMORY");
				goto c;

			}

		}

	c:



/*	spi_flash_erase_sector(START_SECTOR + 1);

	spi_flash_erase_sector(START_SECTOR + 3);

	spi_flash_erase_sector(START_SECTOR + 5);

	spi_flash_erase_sector(START_SECTOR + 8);

	spi_flash_erase_sector(START_SECTOR + 10);

*/	spi_flash_erase_sector(START_SECTOR + 15);

	spi_flash_erase_sector(START_SECTOR + 20);

/*	spi_flash_erase_sector(START_SECTOR + 25);

	spi_flash_erase_sector(START_SECTOR + 30);

	spi_flash_erase_sector(START_SECTOR + 35);

	spi_flash_erase_sector( END_SECTOR );*/




		os_delay_us(500000);
		ets_uart_printf(" Проверка query. Тест 2. П.П.2. очистка некоторых секторов и каждой 3 - й записи");
		os_delay_us(500000);



		for ( i = 3; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ); i += 3 ) {

			for ( a = 0; a < STRING_SIZE - 1; a++ ) {
					alignString[a] = '0';
			}

			p = ShortIntToString( i, ascii );

			memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

			alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


			memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

			alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
			alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


			memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

			alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
			alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

			os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

			switch ( res = delete( alignString ) ) {
				case OPERATION_OK:
					ets_uart_printf("OPERATION_OK");
					data0++;
					system_soft_wdt_stop();
					break;
				case WRONG_LENGHT:
					ets_uart_printf("WRONG_LENGHT");
					goto m;
				case OPERATION_FAIL:
					ets_uart_printf("OPERATION_FAIL");
					goto m;
				case NOTHING_FOUND:
				ets_uart_printf("NOTHING_FOUND");
					break;

			}

		}


		os_printf( " Очищено записей   %d Очищено памяти %d ", data0,  data0 * ALIGN_STRING_SIZE);

		for ( currentSector = START_SECTOR; currentSector <= END_SECTOR; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmpTest, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmpTest[c]);
			}
			system_soft_wdt_stop();
		}

		lenght = 0;
		adress = 0;
		a = 0;

		for ( ; ; ) {

			switch (  query( storage, &lenght, &adress ) ) {
				case OPERATION_OK:
				a++;
				ets_uart_printf("OPERATION_OK");
				os_printf( " Lenght  %d  adress  %d ", lenght, adress );
				os_delay_us(500000);
				os_printf( " Counter  %d ", a );
				os_delay_us(500000);
				uart0_tx_buffer( storage, lenght );

				system_soft_wdt_stop();
				break;
			case OPERATION_FAIL:
				ets_uart_printf("OPERATION_FAIL");
				goto m;
			case READ_DONE:
				ets_uart_printf("READ_DONE");
				os_printf( " Lenght  %d  adress  %d ", lenght, adress );
				uart0_tx_buffer( storage, lenght );

				goto q;

		}
}


q:

	ets_uart_printf(" Тестирование успешно завершено ");

m:

	while ( 1 ) {
		os_delay_us(500000);
		system_soft_wdt_stop();
	}

//**********************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************
Тестирование checkFlash();



user_init(void) {

	initPeriph();
	initWIFI();


	checkFlash();

	{

	uint16_t c, currentSector;

	for ( currentSector = START_SECTOR; currentSector <= USER_SECTOR_IN_FLASH_MEM; currentSector++ ) {
			os_printf( " currentSector   %d", currentSector);
			spi_flash_read( SPI_FLASH_SEC_SIZE * currentSector, (uint32 *)tmp, SPI_FLASH_SEC_SIZE );
			for ( c = 0; SPI_FLASH_SEC_SIZE > c; c++ ) {
				uart_tx_one_char(tmp[c]);
			}
			system_soft_wdt_stop();
		}

	}


while ( 1 ) {
	if( !GPIO_INPUT_GET(INP_1_PIN) ){
		if ( SPI_FLASH_RESULT_OK != spi_flash_erase_sector( USER_SECTOR_IN_FLASH_MEM )  ) {
		 ets_uart_printf("Erase USER_SECTOR_IN_FLASH_MEM fail");
			while(1);
		}
	}
		os_delay_us(500000);
		system_soft_wdt_stop();
}


checkFlash( void ) {

	uint8_t tmpFlashReady[ ALIGN_FLASH_READY_SIZE ];
	uint16_t i;

	for ( i = 0; i < SPI_FLASH_SEC_SIZE; i++ ) {
		tmp[i] = 0xff;
	}

	if ( SPI_FLASH_RESULT_OK != spi_flash_read( USER_SECTOR_IN_FLASH_MEM * SPI_FLASH_SEC_SIZE, \
			                            (uint32 *)tmpFlashReady, ALIGN_FLASH_READY_SIZE ) ) {

		ets_uart_printf("Read fail");
		while(1);
	}

	if ( 0 != strcmp( tmpFlashReady, FLASH_READY ) ) {

/*DEBUG*/		os_printf( "FIRST START");
			os_delay_us(1000000);


		if ( OPERATION_OK != clearSectorsDB() ) {

			ets_uart_printf("clearSectorsDB() fail");
			while(1);
		}


		if ( SPI_FLASH_RESULT_OK != spi_flash_erase_sector( USER_SECTOR_IN_FLASH_MEM )  ) {

			ets_uart_printf("Erase USER_SECTOR_IN_FLASH_MEM fail");
			while(1);
		}

		memcpy( &tmp[FLASH_READY_OFSET], FLASH_READY, sizeof(FLASH_READY) );
		tmp[ sizeof(FLASH_READY) ] = '\n';


		memcpy( &tmp[HEADER_STA_OFSET], HEADER_STA, sizeof(HEADER_STA) );
		tmp[ sizeof(HEADER_STA) + HEADER_STA_OFSET ] = '\n';

		memcpy( &tmp[DEF_SSID_STA_OFSET], DEF_SSID_STA, sizeof(DEF_SSID_STA) );
		tmp[ sizeof(DEF_SSID_STA) + DEF_SSID_STA_OFSET ] = '\n';

		memcpy( &tmp[DEF_PWD_STA_OFSET], DEF_PWD_STA, sizeof(DEF_PWD_STA) );
		tmp[ sizeof(DEF_PWD_STA) + DEF_PWD_STA_OFSET ] = '\n';


		memcpy( &tmp[DEF_SSID_AP_OFSET], DEF_SSID_AP, sizeof(DEF_SSID_AP) );
		tmp[ sizeof(DEF_SSID_AP) + DEF_SSID_AP_OFSET ] = '\n';

		memcpy( &tmp[DEF_PWD_AP_OFSET], DEF_PWD_AP, sizeof(DEF_PWD_AP) );
		tmp[ sizeof(DEF_PWD_AP) + DEF_PWD_AP_OFSET ] = '\n';

		memcpy( &tmp[HEADER_AP_OFSET], HEADER_AP, sizeof(HEADER_AP) );
		tmp[ sizeof(HEADER_AP) + HEADER_AP_OFSET ] = '\n';


		memcpy( &tmp[GPIO_OUT_1_HEADER_OFSET], GPIO_OUT_1_HEADER, sizeof(GPIO_OUT_1_HEADER) );
		tmp[ sizeof(GPIO_OUT_1_HEADER) + GPIO_OUT_1_HEADER_OFSET ] = '\n';

		memcpy( &tmp[GPIO_OUT_1_MODE_OFSET], DEF_GPIO_OUT_MODE, sizeof(DEF_GPIO_OUT_MODE) );
		tmp[ sizeof(DEF_GPIO_OUT_MODE) + GPIO_OUT_1_MODE_OFSET ] = '\n';

		memcpy( &tmp[GPIO_OUT_1_DELEY_OFSET], DEF_GPIO_OUT_DELEY, sizeof(DEF_GPIO_OUT_DELEY) );
		tmp[ sizeof(DEF_GPIO_OUT_DELEY) + GPIO_OUT_1_DELEY_OFSET ] = '\n';


		memcpy( &tmp[GPIO_OUT_2_HEADER_OFSET], GPIO_OUT_2_HEADER, sizeof(GPIO_OUT_2_HEADER) );
		tmp[ sizeof(GPIO_OUT_2_HEADER) + GPIO_OUT_2_HEADER_OFSET ] = '\n';

		memcpy( &tmp[GPIO_OUT_2_MODE_OFSET], DEF_GPIO_OUT_MODE, sizeof(DEF_GPIO_OUT_MODE) );
		tmp[ sizeof(DEF_GPIO_OUT_MODE) + GPIO_OUT_2_MODE_OFSET ] = '\n';

		memcpy( &tmp[GPIO_OUT_2_DELEY_OFSET], DEF_GPIO_OUT_DELEY, sizeof(DEF_GPIO_OUT_DELEY) );
		tmp[ sizeof(DEF_GPIO_OUT_DELEY) + GPIO_OUT_2_DELEY_OFSET ] = '\n';


		memcpy( &tmp[BROADCAST_NAME_HEADER_OFSET], BROADCAST_NAME_HEADER, sizeof(BROADCAST_NAME_HEADER) );
		tmp[ sizeof(BROADCAST_NAME_HEADER) + BROADCAST_NAME_HEADER_OFSET ] = '\n';

		memcpy( &tmp[BROADCAST_NAME_OFSET], BROADCAST_NAME, sizeof(BROADCAST_NAME) );
		tmp[ sizeof(BROADCAST_NAME) + BROADCAST_NAME_OFSET ] = '\n';


/*
 *
 *
 *
 *
 *
 */
		if ( SPI_FLASH_RESULT_OK != spi_flash_write( USER_SECTOR_IN_FLASH_MEM * SPI_FLASH_SEC_SIZE, (uint32 *)tmp, SPI_FLASH_SEC_SIZE ) ) {

				ets_uart_printf("write default param fail");
				while(1);
			}

		{
		uint8_t ascii[10];
		static uint8_t string[] = "HELLO";
		static uint8_t string1[] = "Тестирование";


		uint16_t lenght;
		uint32_t adress;


			uint8_t alignStr[ALIGN_STRING_SIZE];

			uint8_t *p;

			uint16_t c, currentSector;
			uint32_t a, i;

			result res;


			for ( i = STRING_SIZE; i < ALIGN_STRING_SIZE; i++ ) {
				alignString[i] = 0xff;
			}


			os_delay_us(500000);
			ets_uart_printf(" Проверка query. Тест 2 ");
			os_delay_us(500000);


			ets_uart_printf(" П.1 Заполняем базу значениями (ASCII) выровняными по ALIGN_STRING_SIZE символов  ");

			for ( i = 1; i <= ( SPI_FLASH_SEC_SIZE / ALIGN_STRING_SIZE ) * ( END_SECTOR - START_SECTOR + 1 ); i++ ) {

				for ( a = 0; a < STRING_SIZE - 1; a++ ) {
						alignString[a] = '0';
				}

				p = ShortIntToString( i, ascii );

				memcpy( &alignString[ STRING_SIZE - 39 ], string, strlen(string) );

				alignString[ STRING_SIZE - 40 ] = START_OF_FIELD;
				alignString[ STRING_SIZE - 20 ]  = END_OF_FIELD;


				memcpy( &alignString[ STRING_SIZE - 1 - (p - ascii) - 1 - 40], ascii, (p - ascii) );

				alignString[ STRING_SIZE - 15 - 40 ] = START_OF_FIELD;
				alignString[ STRING_SIZE - 2 - 40 ]  = END_OF_FIELD;
				alignString[ STRING_SIZE - 1 ]  = END_OF_STRING;


				memcpy( &alignString[ STRING_SIZE - 40 - 15 - 20 ], string1, strlen( string1 ) );

				alignString[ STRING_SIZE - 40 - 20 - 15 - 1 ] = START_OF_FIELD;
				alignString[ STRING_SIZE - 41 - 15 ]  = END_OF_FIELD;

//				os_printf( " \n %s \n String lenght %d", alignString, ( strlen( alignString ) + 1 ) );

				switch (  insert( alignString ) ) {
					case OPERATION_OK:
						ets_uart_printf("OPERATION_OK");
						system_soft_wdt_stop();
						break;
					case WRONG_LENGHT:
						ets_uart_printf("WRONG_LENGHT");
						goto c;
					case OPERATION_FAIL:
						ets_uart_printf("OPERATION_FAIL");
						goto c;
					case LINE_ALREADY_EXIST:
						ets_uart_printf("LINE_ALREADY_EXIST");
						goto c;
					case NOT_ENOUGH_MEMORY:
					ets_uart_printf("NOT_ENOUGH_MEMORY");
					goto c;

				}

			}
		}
		c:
		ets_uart_printf("OPERATION_OK");

/*
 *
 *
 *
 */


	}
	
	system_restore();

}













